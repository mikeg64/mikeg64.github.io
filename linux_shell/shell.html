<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="web documentation for IntroductiontoLinux ">

    <link rel="stylesheet" type="text/css" media="screen" href="../stylesheets/general.css">

    <title>The Shell</title>
  </head>

   <body>
  
  <!-- global navigation -->
<div id="globalNavigation"> 
  <!-- global navigation links -->
        <a href="#content"><img src="../images/spacer.gif" alt="skip to content" width="1" height="1" /></a> <img src="../images/spacer.gif" alt=" " width="1" height="1" />
		<span><a href="http://shef.ac.uk//www.sheffield.ac.uk/" accesskey="1">Home</a> |</span>
		<span><a href="http://shef.ac.uk//www.sheffield.ac.uk/contact/" accesskey="c">Contact</a> |</span> 
		<span><a href="https://www.sheffield.ac.uk/muse/login" accesskey="m">Log in to MUSE</a></span>
  <!-- // global navigation links -->
   <!-- search engine -->	
  <form name="gs" method="get" action="http://google.shef.ac.uk/search" id="searchBox">
     <p> 
     <label for="searchterms">Search for</label>
      <input type="text" name="q" size="20" maxlength="100" value=" your search" id="searchterms" onfocus="value=''" />
      <!-- <input name="Go" type="submit" value="Go" /> -->
      <input type="submit" name="btnG" value="Search" class="submit" />
    </p>
            <input type="hidden" name="sort" value="date:D:L:d1" />
            <input type="hidden" name="output" value="xml_no_dtd" />
            <input type="hidden" name="ie" value="UTF-8" />
            <input type="hidden" name="oe" value="UTF-8" />
            <input type="hidden" name="client" value="default_frontend" />
            <input type="hidden" name="proxystylesheet" value="default_frontend" />
            <input type="hidden" name="site" value="default_collection" />
  </form>
  <!-- // search engine -->
</div>
<!-- // global navigation -->





    <!-- HEADER -->
<div id="header">

  <table summary="Header Table"><tr>
	 <td id="headerLeft">
		  <div id="headerCrest">
			<a href="http://www.shef.ac.uk/"><img src="../images/crest-l.gif" alt="The University of Sheffield" /></a> 
		  </div>
    </td>
	<td id="headerRight">
	        <!-- page heading  -->
		  <div id="headerTitle"> 
		<h1 id="pageTitle">The Shell</h1>
		  </div>
		  <!-- // page heading -->
    </td>
  </tr>
 </table>
</div>    
  
  




<h1 id="the-shell">The Shell</h1>

<p><strong>Material by Milad Fatenejad, Sasha Wood, Radhika Khetani and Karin Lagesen</strong></p>

<p><em>Modified by Shoaib Sufi for Manchester, 2014 and by Seb James for Sheffield 2015</em></p>



<h1 id="this-tutorial">This tutorial</h1>

<p>This is a tutorial to introduce you to the <em>shell</em> and how it might be <br>
useful for your research.</p>

<h1 id="what-is-a-shell">What is a shell?</h1>

<p>A <em>shell</em> is a program which reads a command that you typed; decides <br>
what to do with it; does it; then prints out any text that was <br>
generated.</p>

<p>It’s a middleman between you and the core (or <em>kernel</em>) of the computer.</p>

<p>A <em>terminal</em> is a program that gives you access to the shell - <br>
think of the terminal as the window enclosing the shell, and the shell <br>
as that little prompt at the bottom:</p>

<pre><code>`you@somecomputer:~$`
</code></pre>

<p>The shell we’ll use is called <em>bash</em>. Although there are others, bash <br>
is the most commonly used shell. The shell can be viewed as an <br>
interpreted computer programming language with a focus on interactive <br>
use.</p>



<h1 id="what-the-shell-does-it-calls-built-in-commands-and-programs">What the shell does: It calls built-in commands and programs</h1>

<p>Usually, when you type a command at the shell, all you want the shell <br>
to do is to find, and execute a program.</p>

<p>For example, <code>ps</code> is a standalone program which gives you some <br>
information about the processes running on the computer:</p>

<pre><code>ps
</code></pre>

<p>When you type this, the shell first checks if <code>ps</code> is one of its own, <br>
special built-in keywords. It then looks in its list of “places where <br>
there might be programs” and runs the first one it finds. (That list <br>
is called the PATH; more on that later).</p>

<p>You can see the ps program that you just ran by listing it:</p>

<pre><code>ls /bin/ps
</code></pre>

<p>Some commands you’ll use are <em>bash builtins</em>. A couple of examples are <br>
<code>alias</code> and <code>source</code>. When you type these, you activate code which is <br>
part of the shell itself. This is also true of programming constructs <br>
such as conditionals (if/else), loops, variable assignments and so on.</p>



<h1 id="the-example-manipulating-experimental-data-files">The Example: Manipulating Experimental Data Files</h1>

<p>We will spend most of our time learning about the basics of the shell <br>
by manipulating some experimental data from a hearing test. </p>

<p>To get the data:</p>

<pre><code>git clone https://github.com/rcgsheffield/linux-shell.git
</code></pre>

<p>The git command will grab all of the data needed for this workshop from GitHub.</p>

<p>Now we’ll *c*hange *d*irectory into the directory tree which git cloned for us:</p>

<pre><code>cd linux_shell
</code></pre>



<h1 id="moving-around-the-file-system">Moving around the file system</h1>

<p>The filesystem is like a tree. On Unix systems, there’s only one root <br>
of the tree (the analogy ends at the ground). Windows systems may have <br>
several trees (C:\ D:\ and so on). The bottom of the tree is called <br>
the root and in Unix, it’s represented by the symbol ‘/’</p>

<p>Navigating the filesystem at the shell requires some typing, but there <br>
are a number of shortcuts and conveniences to ease the pain.</p>

<p>First we have to know where we are. The program <code>pwd</code> (print working <br>
directory) tells you where you are sitting in the directory tree. The <br>
command <code>ls</code> will list the files in the current directory. Directories <br>
are often called “folders” because of how they are represented in <br>
GUIs. Directories are just listings of files. They can contain other <br>
files or directories.</p>

<p>When you start up a terminal on most systems, you will start in a special <br>
directory called the <em>home</em> directory. If you’re using the managed desktop, <br>
you’ll initially find yourself in a Desktop directory, so change to your home:</p>

<pre><code>cd
</code></pre>

<p>Every user has their own home <br>
directory where they have full access to create and delete files and <br>
directories. At the start of a session the <code>pwd</code> command tells us what <br>
the name of our home directory is.  The last word in that listing <br>
should also be the name of your user.  You can also find out your user <br>
name by entering the command <code>whoami</code>.</p>

<p>You can always get back to your home directory by typing <code>cd</code> (return).</p>



<h1 id="file-types">File Types</h1>

<p>When you enter the <code>ls</code> command, it lists the contents of the current <br>
directory. There are several items in your home directory.</p>

<p>Let’s create an empty file using the <code>touch</code> command. Enter the <br>
command:</p>

<pre><code>touch testfile
</code></pre>

<p>Then list the contents of the directory again. You should see that a <br>
new entry, called <code>testfile</code>, exists. The <code>touch</code> command just <br>
creates an empty file.</p>

<p>*touch is Super Useful! Why? because it updates the last-modified date <br>
 of the file. This can be useful in scripts to check if you need to <br>
 carry out some function or other, perhaps on data being generated by <br>
 another program.*</p>

<p>To get a fuller listing, add the <code>-l</code> switch. This will show the file <br>
size, the owner and information about the permissions applied to the <br>
file. If the entry is a directory, then the first letter will be a <br>
“d”. The fifth column shows you the size of the entries in <br>
bytes. Notice that <code>testfile</code> has a size of zero.</p>

<p>Try <code>ls -l -h</code> (or equivalently <code>ls -lh</code>). That makes the file size <br>
show up in “human readable” format.</p>

<p>Now, let’s get rid of <code>testfile</code>. To remove a file, just enter the <br>
command:</p>

<pre><code>rm testfile
</code></pre>

<p>The <code>rm</code> command can be used to remove files. If you enter <code>ls</code> again, <br>
you will see that <code>testfile</code> is gone.</p>



<h1 id="changing-directories">Changing Directories</h1>

<p>Now, let’s move to a different directory. The command <code>cd</code> (change <br>
directory) is used to move around. We used <code>cd</code> earlier to get us into <br>
the <code>linux_shell</code> directory.  Now let’s move into the <br>
<code>shell</code> directory. Enter the following command:</p>

<pre><code>cd shell
</code></pre>

<p>Now use the <code>ls</code> command to see what is inside this directory.  This <br>
directory contains all of the material for the shell part of this boot <br>
camp. Now move to the directory containing the data for the shell <br>
tutorial:</p>

<pre><code>cd data
</code></pre>

<p>If you enter the <code>cd</code> command by itself, you will return to the home <br>
directory. Try this, and then navigate back to the <code>shell</code> <br>
directory.</p>



<h1 id="arguments">Arguments</h1>

<p>Most programs take additional arguments that control their exact <br>
behavior. For example, <code>-F</code> and <code>-l</code> are arguments to <code>ls</code>.  The <code>ls</code> <br>
program, like many programs, take a lot of arguments. But how do we <br>
know what the options are to particular commands?</p>

<p>Most commonly used shell programs have a manual. You can access the <br>
manual using the <code>man</code> program. Try entering:</p>

<pre><code>man ls
</code></pre>

<p>This will open the manual page for <code>ls</code>. Use the space key to go <br>
forward and b to go backwards. When you are done reading, just hit <code>q</code> <br>
to exit.</p>

<p>Note: if you are using Git Bash on Windows you will not have access to <br>
<code>man</code>. People have hosted the man pages at various sites which is <br>
useful for people on any platform e.g <br>
www.kernel.org/doc/man-pages/online_pages.html or <br>
www.linuxmanpages.com</p>

<p>Programs that are run from the shell can get extremely complicated. To <br>
see an example, open up the manual page for the <code>find</code> program, which <br>
we will use later this session. No one can possibly learn all of these <br>
arguments, of course. So you will probably find yourself referring <br>
back to the manual page frequently. Note: sometimes it can be pretty <br>
difficult to understand what it says in a man file. However, each time <br>
you read a man file you will understand more of it.</p>



<h1 id="job-control">Job control</h1>

<p>Most programs, like <code>ls</code> and <code>cd</code> finish very quickly and output their <br>
results immediately. Some programs last a long time and may output <br>
their results into a file, so they’ll sit there holding your command <br>
line hostage until they finish. To allow long lived programs to be <br>
executed without losing access to the command line, most shells have a <br>
form of <em>job control</em> built in.</p>

<p>If a job is run in <em>the foreground</em>, then access to the command line <br>
is suspended until the job finishes. By default, a command you run at <br>
the shell will run in the foreground.</p>

<p>A job can be run in the background, in which case it will give the <br>
command line back to you for the execution of additional commands.</p>

<p>To run a job in the background, add an &amp; after the command:</p>

<pre><code>ps &amp;
</code></pre>

<p>This is particularly useful for graphical programs which open up their <br>
own window, or for running a program a few times in parallel.</p>

<pre><code>ps &amp; ps &amp; 
</code></pre>

<p>If you put an interactive program like an editor into the background, <br>
it’ll effectively disappear. GNU Nano is a text editor which is both <br>
common and easy to use. Try it out: open it with</p>

<pre><code>nano
</code></pre>

<p>and then exit with Ctrl-x. As we don’t have nano on the Managed Desktop, <br>
you can use vi for this example. vi is more common than nano, but much <br>
more confusing for new users:</p>

<pre><code>vi
</code></pre>

<p>You have to exit vi with <code>:q!</code>.</p>

<p>Now run it in the background:</p>

<pre><code>nano &amp;
</code></pre>

<p>or</p>

<pre><code>vi &amp;
</code></pre>

<p>Not so useful. You see the shell outputs the editor’s job number and also its <br>
process id. You can list the current running jobs with</p>

<pre><code>jobs
</code></pre>

<p>If it’s job 1, then you can bring it into the foreground with</p>

<pre><code>%1
</code></pre>

<p>You can stop the job with Ctrl-z and then put it into the <br>
background with <code>bg</code> or into the foreground with <code>fg</code>.</p>

<p>You can kill a stopped job with</p>

<pre><code>kill %1
</code></pre>

<p>Assuming it was job number 1.</p>



<h1 id="examining-the-contents-of-other-directories">Examining the contents of other directories</h1>

<p>By default, the <code>ls</code> commands lists the contents of the working <br>
directory (i.e. the directory you are in). However, you can also <br>
give <code>ls</code> the names of other directories to view. Navigate to the <br>
home directory if you are not already there. Then enter the <br>
command:</p>

<pre><code>ls linux_shell
</code></pre>

<p>This will list the contents of the <code>linux_shell</code> directory without <br>
you having to navigate there. Now enter:</p>

<pre><code>ls linux_shell/shell
</code></pre>

<p>This prints the contents of <code>shell</code>. The <code>cd</code> command works in a <br>
similar way. Try entering:</p>

<pre><code>cd linux_shell/shell
</code></pre>

<p>and you will jump directly to <code>shell</code> without having to go through <br>
the intermediate directory.</p>



<h1 id="absolute-vs-relative-paths">Absolute vs. Relative Paths</h1>

<p>The <code>cd</code> command takes an argument which is the directory <br>
name. Directories can be specified using either a <em>relative path</em> or <br>
an <em>absolute path</em>. The directories on the computer are arranged into <br>
a hierarchy. The absolute path tells you where a directory is in that <br>
hierarchy, all the way from the root and up.</p>

<p>Navigate to the home directory. Now, enter the <code>pwd</code> command and you <br>
should see the full name of your home directory.  This tells you that <br>
you are in a directory that is named the same as your user, which sits <br>
inside one or more other directories. The very top of the hierarchy is <br>
a directory called <code>/</code> which is usually referred to as the *root <br>
directory*.</p>

<p>First, figure out again what the absolute path to your home directory <br>
was. Now enter the following command (replace the stuff in &lt;&gt; with the <br>
results from <code>pwd</code>).</p>

<pre><code>cd &lt;pwd-results&gt;/linux_shell/shell
</code></pre>

<p>This jumps to <code>shell</code>. Now go back to the home directory. We saw <br>
earlier that the command</p>

<pre><code>cd linux_shell/shell
</code></pre>

<p>had the same effect - it took us to the <code>shell</code> directory. But, <br>
instead of specifying the absolute path which started with a /, we <br>
specified a <em>relative path</em>. In other words, we specified the path <br>
relative to our current directory. A absolute path always starts with <br>
a <code>/</code>. A relative path does not. You can usually use either an <br>
absolute path or a relative path depending on what is most <br>
convenient. If we are in the home directory, it is more convenient to <br>
just enter the relative path since it involves less typing.</p>

<p>Now, list the contents of the <code>/bin</code> directory. Do you see anything <br>
familiar in there?</p>



<h1 id="saving-time-with-shortcuts-wild-cards-and-tab-completion">Saving time with shortcuts, wild cards, and tab completion</h1>



<h2 id="shortcuts">Shortcuts</h2>

<p>There are some shortcuts which you should know about. Referring to the <br>
home directory is very common. The shell recognises the tilde <br>
character, <code>~</code>, as a shortcut for your home directory. Navigate to the <br>
<code>shell</code> directory, then enter the command:</p>

<pre><code>ls ~
</code></pre>

<p>This prints the contents of your home directory, without you having to <br>
type the absolute path. The shortcut <code>..</code> always refers to the directory <br>
above your current directory. Thus: </p>

<pre><code>ls ..
</code></pre>

<p>prints the contents of the ~/linux_shell directory. You can chain <br>
these together, so:</p>

<pre><code>ls ../../
</code></pre>

<p>prints the contents of what should be your home <br>
directory. Finally, the special directory <code>.</code> always refers to your <br>
current directory. So, <code>ls</code>, <code>ls .</code>, and <code>ls ././././.</code> all do the <br>
same thing, they print the contents of the current directory. This may <br>
seem like a useless shortcut right now, but we’ll see when it is <br>
needed in a little while.</p>

<p>To summarize, the commands <code>ls ~</code>, <code>ls ~/.</code>, <code>ls ../../</code>, and <code>ls <br>
&lt;absolute path to home directory&gt;</code> all do exactly the same <br>
thing. These shortcuts are not necessary, they are provided for your <br>
convenience.</p>



<h2 id="our-data-set-cochlear-implants">Our data set: Cochlear Implants</h2>

<p>A cochlear implant is a small electronic device that is surgically <br>
implanted in the inner ear to give deaf people a sense of <br>
hearing. More than a quarter of a million people have them, but there <br>
is still no widely-accepted benchmark to measure their effectiveness. <br>
In order to establish a baseline for such a benchmark, teenagers with <br>
CIs were asked to listen to audio files on their computer and report:</p>

<ol>
<li>the quietest sound they could hear</li>
<li>the lowest and highest tones they could hear</li>
<li>the narrowest range of frequencies they could discriminate</li>
</ol>

<p>To participate, test subjects were played an audio sample by a lab <br>
tech who then recorded their data - when the subjects <br>
first heard the sound, or first heard a difference in the sound.  Each <br>
set of test results were written out to a text file, one set per file. <br>
Each participant has a unique subject ID, and a made-up subject name. <br>
Each experiment has a unique experiment ID. The experiment has <br>
collected 351 files so far.</p>

<p>The data is a bit of a mess! There are inconsistent file names, there <br>
are extraneous “NOTES” files that we’d like to get rid of, and the <br>
data is spread across many directories. We are going to use shell <br>
commands to get this data into shape. By the end we would like to:</p>

<ol>
<li><p>Put all of the data into one directory called “alldata”</p></li>
<li><p>Have all of the data files in there, and ensure that every file <br>
has a “.txt” extension</p></li>
<li><p>Get rid of the extraneous “NOTES” files</p></li>
</ol>



<h2 id="globbing-with-wild-cards-super-useful">Globbing with wild cards [Super useful]</h2>

<p>Navigate to the <code>~/linux_shell/shell/data/THOMAS</code> directory. This <br>
directory contains our hearing test data for THOMAS. If we type <code>ls</code>, <br>
we will see that there are a bunch of files which are just four digit <br>
numbers. By default, <code>ls</code> lists all of the files in a given <br>
directory. The <code>*</code> character is a shortcut for “everything”. Thus, if <br>
you enter <code>ls *</code>, you will again see all of the contents of a given <br>
directory. This * can be combined with other characters. Now try this command:</p>

<pre><code>ls *1
</code></pre>

<p>This lists every file that ends with a <code>1</code>. This command:</p>

<pre><code>ls /usr/bin/*.sh
</code></pre>

<p>Lists every file in <code>/usr/bin</code> that ends in the characters <code>.sh</code>.</p>

<p>This command:</p>

<pre><code>ls *4*1
</code></pre>

<p>lists every file in the current directory which contains the number <br>
<code>4</code>, and ends with the number <code>1</code>. There are four such files: <code>0241</code>, <br>
<code>0341</code>, <code>0431</code>, and <code>0481</code>. </p>

<p>So how does this actually work? When the shell (and this is a <br>
bash-specific explanation; other shells may vary) sees a word that <br>
contains the <code>*</code> character, it automatically looks for files that <br>
match this wild card; * means “anything”. In this case, it identified <br>
four such files. Then, it replaced the <code>*4*1</code> with the list of files, <br>
separated by spaces *and passes that as the argument list to the <br>
program*. In other words, the two commands:</p>

<pre><code>ls *4*1
ls 0241 0341 0431 0481
</code></pre>

<p>result in an identical call to <code>ls</code>. The <code>ls</code> command cannot tell the <br>
difference between these two things.</p>

<p>The expansion of wild cards by the shell is known as <em>globbing</em>. There <br>
are some other wild cards beyond the * character which you can search <br>
up on the internet.</p>

<hr>



<h2 id="short-exercise">Short Exercise</h2>

<p>Do each of the following using a single <code>ls</code> command without <br>
navigating to a different directory.</p>

<ol>
<li>List all of the files in <code>/bin</code> that contain the letter <code>a</code></li>
<li>Can you figure out if there are any directories inside of /bin?</li>
</ol>

<hr>



<h2 id="more-on-expansion-quotation-marks-and-spaces-in-filenames-super-useful">More on expansion: quotation marks and spaces in filenames [Super Useful]</h2>

<p>Spaces are important when you type commands in the shell:</p>

<pre><code>cd ../.. # To go back to the 'shell' directory
</code></pre>

<p>This command lists two files:</p>

<pre><code>ls 4fileone 4filetwo
</code></pre>

<p>This command lists one file:</p>

<pre><code>ls "4fileone 4filetwo"
</code></pre>

<p>The shell interprets the quotation marks and passes the string <br>
“4fileone 4filetwo” to the <code>ls</code> program.</p>

<p>This is how you can refer to a file containing a space. Another way is <br>
to “escape the space”:</p>

<pre><code>ls 4fileone\ 4filetwo
</code></pre>

<p>The backslash there tells the shell to interpret the space as part of <br>
the string and not as the separator between one argument and another.</p>

<p>Dealing with spaces is a bit annoying on the command line, which is <br>
why most Linux and Unix users tend to avoid spaces in their file <br>
names.</p>

<p>Lastly,</p>

<pre><code>ls '4fileone 4filetwo'
</code></pre>

<p>Is similar to <code>ls "4fileone 4filetwo"</code>, but has an important <br>
difference. Try this:</p>

<pre><code>ls "$HOME"
</code></pre>

<p>and this:</p>

<pre><code>ls '$HOME'
</code></pre>

<hr>



<h2 id="short-exercise-1">Short Exercise</h2>

<p>Work through the above examples which used <code>ls</code>, replacing <code>ls</code> with <code>cat</code>. <br>
This should prove that the quotation marks are important and that the use of <br>
spaces in filenames is inadvisable.</p>

<hr>



<h2 id="tab-completion-super-useful">Tab Completion [Super useful]</h2>

<p>Navigate to the home directory. Typing out directory names can waste a <br>
lot of time. When you start typing out the name of a directory, then <br>
hit the tab key, the shell will try to fill in the rest of the <br>
directory name. For example, enter:</p>

<pre><code>cd 2&lt;tab&gt;
</code></pre>

<p>The shell will fill in the rest of the directory name for <br>
<code>linux_shell</code>. Press enter to enter the boot camp directory. Next, go <br>
into the shell directory and do:</p>

<pre><code>ls 3&lt;tab&gt;&lt;tab&gt;
</code></pre>

<p>When you hit the first tab, nothing happens. The reason is that there <br>
are multiple file in this directory which start with <br>
3. Thus, the shell does not know which one to fill in. When you hit <br>
tab again, the shell will list the possible choices. </p>

<p>Tab completion can also fill in the names of programs. For example, <br>
enter <code>e&lt;tab&gt;&lt;tab&gt;</code>. You will see the name of every program that <br>
starts with an <code>e</code>. One of those is <code>echo</code>. If you enter <code>ec&lt;tab&gt;</code> you <br>
will see that tab completion works.</p>



<h1 id="command-history">Command History</h1>

<p>You can easily access previous commands. <code>history</code> (a bash built-in) <br>
lists the command history.</p>

<pre><code>[seb@sebpad 08:48:28 shell]$ history
 (Extra output snipped)
 2053  ls
 2054  which history
 2055  history
[seb@sebpad 08:48:45 shell]$ 
</code></pre>

<p>You can re-call a command from that history like this:</p>

<pre><code>!2053
</code></pre>

<p>This will call <code>ls</code> from the short list above.</p>



<h2 id="navigating-and-searching-the-command-history-super-useful">Navigating and searching the command history [Super useful]</h2>

<p>You can quickly access recent commands from the history and search the <br>
history:</p>

<p>Hit the up arrow.  Hit it again.  You can step backwards through your <br>
command history.  The down arrow takes you forwards in the command <br>
history.</p>

<p>^-C will cancel the command you are writing, and give you a fresh prompt.</p>

<p>^-R will do a reverse-search through your command history. This is <br>
very useful. If you find a partial match you can keep pressing ^-R <br>
until you find the instance you are interested in.</p>



<h1 id="which-program">Which program?</h1>

<p>Commands like <code>ls</code>, <code>rm</code>, and <code>cd</code> are just ordinary programs on the <br>
computer. A program is just a file that you can <em>execute</em>. The program <br>
<code>which</code> tells you the location of a particular program. For example:</p>

<pre><code>which ls
</code></pre>

<p>Will return “/bin/ls”. Thus, we can see that <code>ls</code> is a program that <br>
sits inside of the <code>/bin</code> directory. Now enter:</p>

<pre><code>which find
</code></pre>

<p>You will see that <code>find</code> is a program that sits inside of the <br>
<code>/bin</code> directory (it might be <code>/usr/bin</code> on some platforms).</p>

<p>You could have an executable program anywhere on the filesystem. When <br>
we enter a program name, like <code>ls</code>, and hit enter, how does the shell <br>
know where to look for that program?</p>

<p>How does it know to run <code>/bin/ls</code> when we enter <code>ls</code> and not <br>
<code>/home/me/usr/bin/ls</code>?</p>

<p>The answer is that when we enter a program name and hit enter, there <br>
are a few standard places that the shell automatically looks. If it <br>
can’t find the program in any of those places, it will print an error <br>
saying “command not found”. Enter the command:</p>

<pre><code>echo $PATH
</code></pre>

<p>This will print out the value of the <code>PATH</code> environment variable. <br>
Notice that a list of directories, separated by colon characters, is <br>
returned. These are the places the shell looks for programs to run. If <br>
your program is not in this list, then an error is printed. The shell <br>
ONLY checks in the places listed in the <code>PATH</code> environment variable.</p>

<p>*Note: You can modify the PATH environment variable; adding special <br>
 directories containing the programs you have written; this is super <br>
 useful on Iceberg, where you can’t install programs into /bin or <br>
 /usr/bin*</p>

<p>Navigate to the <code>shell</code> directory and list the contents. You will <br>
notice that there is a program (executable file) called <code>hello</code> in <br>
the shell directory. Now, try to run the program by entering:</p>

<pre><code>hello
</code></pre>

<p>You <em>should</em> get an error saying that hello cannot be found. That is <br>
because the directory <code>&lt;your home <br>
directory&gt;/linux_shell/shell</code> is not in the <code>PATH</code> (this is <br>
actually a security feature).  However, it turns <br>
out that in Windows git bash, the current working directory IS in the path.</p>

<p>In any case, you can run the <code>hello</code> program by entering:</p>

<pre><code>./hello
</code></pre>

<p>Remember that <code>.</code> is a shortcut for the current working <br>
directory. This tells the shell to run the <code>hello</code> program which is <br>
located right here. So, you can run any program by entering the path <br>
to that program. You can run <code>hello</code> equally well by specifying:</p>

<pre><code>&lt;path to home directory&gt;/linux_shell/shell/hello
</code></pre>

<p>Or by entering:</p>

<pre><code>../shell/hello
</code></pre>

<p>While you’re at it; try:</p>

<pre><code>$HOME/linux_shell/shell/hello
</code></pre>

<p>and</p>

<pre><code>/home/$USER/linux_shell/shell/hello
</code></pre>

<p>Neat huh? HOME and USER are two more examples of environment <br>
variables.</p>

<p>When there are no <code>/</code> characters, the shell assumes you want to look <br>
in one of the default places for the program.</p>



<h1 id="calling-matlab-from-the-shell">Calling MatLab from the shell</h1>

<ul>
<li>This section can’t be run with the Sheffield Windows Managed Desktop *</li>
</ul>

<p>In can be convenient to call MatLab from the command line.</p>

<p>For me the location of <code>matlab</code> was <br>
<em>/Applications/MATLAB_R2013a.app/bin/matlab</em>. If running <code>matlab</code> <br>
produces a <em>command not found</em> type of message then you can either use <br>
the absolute path for matlab or you can add it to your <em>PATH</em> which is <br>
the list of locations that the shell searches for commands and <br>
programs:</p>

<pre><code>MATLAB_LOCATION=/Applications/MATLAB_R2013a.app/bin
export PATH=$MATLAB_LOCATION:$PATH
</code></pre>

<p>*You can put these lines into your .bashrc file to have them run every <br>
 time you log in*</p>

<p>Now using <code>nano</code> or <code>notepad</code> make a file called <code>hello.m</code> and put the following <br>
contents in and save the file:</p>

<pre><code>disp('hello')
exit()
</code></pre>

<p>Then from the same directory call the following command:</p>

<pre><code>matlab -nosplash -nodesktop -r hello -logfile out.txt
</code></pre>

<p>This calls matlab without a GUI, the filename is <code>hello.m</code> but the <br>
argument to -r is just <em>hello</em> and the output is written to stdout and <br>
a file called <code>out.txt</code> - you can use <code>nano</code> or <code>cat</code> to check the <br>
contents.</p>

<p>Another way of calling MatLab is by using a <em>Here Document</em>. The Here <br>
Document redirects the output of a command block into the <em>stdin</em> of a <br>
program or command. In our current example, rather than putting the <br>
list of commands in a file and then calling <code>matlab</code> you can place <br>
them in the following way:</p>

<pre><code>matlab -nosplash -nodesktop &lt;&lt;HEREMARKER
disp('hello')
exit()
HEREMARKER         
</code></pre>

<p>One benefit of this approach is that you can keep all of your MatLab <br>
and bash commands in one file if this were a script.</p>

<p>For more information about <em>Here Documents</em> please refer to <a href="http://www.tldp.org/LDP/abs/html/here-docs.html">The LDP’s <br>
Advanced Bash-Scripting <br>
Guide</a></p>

<hr>



<h1 id="short-exercise-2">Short Exercise</h1>

<p>Using the above example write a <em>Here Document</em> based script for <br>
MatLab, modify it’s permissions and run it to test that it works.</p>

<hr>



<h1 id="calling-the-shell-from-matlab">Calling the shell from matlab</h1>

<p>Learning about the shell is useful because it makes it easier to call <br>
external programs from matlab scripts. When you use the system() call <br>
in matlab, it actually launches a shell, then passes the content of <br>
the system() call’s argument to the shell, meaning you can do things <br>
like:</p>

<pre><code>[status, stdout] = system ('ls ~/somedir/');
</code></pre>

<p>This assumes that your matlab is installed on Linux or Mac; the <br>
Windows matlab system call won’t call a bash shell; instead it calls <br>
the standard DOS shell.</p>

<p>You can shortcut to calling a shell command with the ! character in matlab:</p>

<pre><code>! ls
</code></pre>



<h1 id="examining-files">Examining Files</h1>

<p>We now know how to switch directories, run programs, and look at the <br>
contents of directories, but how do we look at the contents of files?</p>

<p>The easiest way to examine a file is to just print out all of the <br>
contents using the program <code>cat</code>. Enter the following command:</p>

<pre><code>cat ex_data.txt
</code></pre>

<p>This prints out the contents of the <code>ex_data.txt</code> file. This file  <br>
contains an example of how our data is formatted. If you enter:</p>

<pre><code>cat ex_data.txt ex_data.txt
</code></pre>

<p>It will print out the contents of <code>ex_data.txt</code> twice. <code>cat</code> just <br>
takes a list of file names and writes them out one after another (this <br>
is where the name comes from, <code>cat</code> is short for concatenate). </p>

<hr>



<h1 id="short-exercises">Short Exercises</h1>

<ol>
<li><p>Print out the contents of the <code>~/linux_shell/shell/dictionary.txt</code> <br>
file. What does this file contain?</p></li>
<li><p>Without changing directories, (you should still be in <code>shell</code>), <br>
use one short command to print the contents of all of the files in <br>
the <code>&lt;your home directory&gt;/linux_shell/shell/data/THOMAS</code> directory.</p></li>
</ol>

<hr>

<p><code>cat</code> is a terrific program, but when the file is really big, it can <br>
be annoying to use. Try this:</p>

<pre><code>cat  ~/linux_shell/shell/dictionary.txt
</code></pre>

<p>All you can see is about the last 25 lines of that file. How to see <br>
the previous lines?</p>

<p>One way is to scroll up in your terminal or [Super useful tip] press <br>
Shift-PgUp), but this has limitations (one is that neither works on <br>
the Windows Managed Desktop’s installation of git bash!).</p>

<p>The file viewing program, <code>less</code>, is a good tool for viewing long <br>
files. Enter the following command:</p>

<pre><code>less ~/linux_shell/shell/dictionary.txt
</code></pre>

<p><code>less</code> opens the file, and lets you navigate through it. The commands <br>
are identical to the <code>man</code> program. Use “space” to go forward and hit <br>
the “b” key to go backwards. The “g” key goes to the beginning of the <br>
file and “G” goes to the end. When you are done, hit “q” to quit.</p>

<p><code>less</code> also gives you a way of searching through files. Just hit the <br>
“/” key to begin a search. Enter the word you would like <br>
to search for and hit enter. It will jump to the next location where <br>
that word is found. Try searching the <code>dictionary.txt</code> file for the <br>
word “cat”. If you hit “/” then “enter”, <code>less</code> will just repeat <br>
the previous search. <code>less</code> searches from the current location and <br>
works its way forward. If you are at the end of the file and search <br>
for the word “cat”, <code>less</code> will not find it. You need to go to the <br>
beginning of the file and search.</p>

<p>Remember, the <code>man</code> program uses the same commands (in fact, it uses <br>
less as its viewer!), so you can search documentation using “/” as well.</p>

<hr>



<h1 id="short-exercise-3">Short Exercise</h1>

<p>Use the commands we’ve learned so far to figure out how to search <br>
in reverse while using <code>less</code>.</p>

<hr>



<h1 id="redirection">Redirection</h1>

<p>Let’s turn to the experimental data from the hearing tests.  <br>
This data is located in the <code>~/linux_shell/shell/data</code> <br>
directory. Each subdirectory corresponds to a particular participant <br>
in the study. Navigate to the <code>Bert</code> subdirectory in <code>data</code>.  First, <br>
press <code>ls</code> to look at the files. There <br>
are a bunch of text files which contain experimental data <br>
results. Lets print them all:</p>

<pre><code>cat *
</code></pre>

<p>Now enter the following command:</p>

<pre><code>cat * &gt; ../all_data
</code></pre>

<p>This tells the shell to take the output from the <code>cat *</code> command and <br>
dump it into a new file called <code>../all_data</code>. To verify that this <br>
worked, examine the <code>all_data</code> file. If <code>all_data</code> had already <br>
existed, we would overwritten it. So the <code>&gt;</code> character tells the shell <br>
to take the output from whatever is on the left and dump it into the <br>
file on the right. The <code>&gt;&gt;</code> characters do almost the same thing, <br>
except that they will append the output to the file if it already <br>
exists.</p>

<hr>



<h1 id="short-exercise-4">Short Exercise</h1>

<p>Use <code>&gt;&gt;</code>, to append the contents of all of the files whose name contains the <br>
number 4 in the directory:</p>

<pre><code>&lt;your home directory&gt;/linux_shell/shell/data/gerdal
</code></pre>

<p>to the existing <code>all_data</code> file. Thus, when you are done <code>all_data</code> <br>
should contain all of the experiment data from Bert and any <br>
experimental data file from gerdal that contains the number 4.</p>

<hr>



<h1 id="creating-moving-copying-and-removing">Creating, moving, copying, and removing</h1>

<p>We’ve created a file called <code>all_data</code> using the redirection operator <br>
<code>&gt;</code>. This file is critical - it’s our analysis results - so we want to <br>
make copies so that the data is backed up. <br>
Lets copy the file using the <code>cp</code> command. The <code>cp</code> <br>
command backs up the file. Navigate to the <code>data</code> directory and enter:</p>

<pre><code>cp all_data all_data_backup
</code></pre>

<p>Now <code>all_data_backup</code> has been created as a copy of <code>all_data</code>. We can <br>
move files around using the command <code>mv</code>. Enter this command:</p>

<pre><code>mv all_data_backup /tmp/
</code></pre>

<p>This moves <code>all_data_backup</code> into the directory <code>/tmp</code>. The directory <br>
<code>/tmp</code> is a special directory that all users can write to. It is a <br>
temporary place for storing files. Data stored in <code>/tmp</code> may be <br>
automatically deleted when the computer shuts down.</p>

<p>The <code>mv</code> command is also one way to rename files. Since this file is so <br>
important, let’s rename it:</p>

<pre><code>mv all_data all_data_IMPORTANT
</code></pre>

<p>Type in <code>ls</code>, and you will see that file name has been changed to <br>
all_data_IMPORTANT. Let’s delete the backup file now:</p>

<pre><code>rm /tmp/all_data_backup
</code></pre>

<p>The <code>mkdir</code> command is used to create a directory. Just enter <code>mkdir</code> <br>
followed by a space, then the directory name. </p>

<hr>



<h1 id="short-exercise-5">Short Exercise</h1>

<p>Do the following:</p>

<ol>
<li>Rename the <code>all_data_IMPORTANT</code> file to <code>all_data</code>.</li>
<li>Create a directory in the <code>data</code> directory called <code>foo</code></li>
<li>Then, copy the <code>all_data</code> file into <code>foo</code></li>
<li>Do <code>ls foo</code> to have a look inside the new directory </li>
</ol>

<hr>

<p>By default, <code>rm</code>, will NOT delete directories. You can tell <code>rm</code> to <br>
delete a directory using the <code>-r</code> option. Enter the following command:</p>

<pre><code>rm -r foo
</code></pre>



<h1 id="count-the-words">Count the words</h1>

<p>The <code>wc</code> program (word count) counts the number of lines, words, and <br>
characters in one or more files. Make sure you are in the <code>data</code> <br>
directory, then enter the following command:</p>

<pre><code>wc Bert/* gerdal/*4*
</code></pre>

<p>For each of the files indicated, <code>wc</code> has printed a line with three <br>
numbers and also the relative file name. The first is the number of lines in that file. The second is <br>
the number of words. Third, the total number of characters is <br>
indicated. The bottom line contains this information summed over all of <br>
the files. Thus, there were 10445 characters in total. </p>

<p>Remember that the <code>Bert/*</code> and <code>gerdal/*4*</code> files were merged <br>
into the <code>all_data</code> file. So, we should see that <code>all_data</code> contains <br>
the same number of characters:</p>

<pre><code>wc all_data
</code></pre>

<p>Every character in the file takes up one byte of disk space (as it contain’s <code>ASCII text</code>. Thus, the <br>
size of the file in bytes should also be 10445. Let’s confirm this:</p>

<pre><code>ls -l all_data
</code></pre>

<p>Remember that <code>ls -l</code> prints out detailed information about a file and <br>
that the fifth column is the size of the file in bytes.</p>

<hr>



<h1 id="the-awesome-power-of-the-pipe">The awesome power of the Pipe</h1>

<p>Suppose I wanted to only see the total number of character, words, and <br>
lines across the files <code>Bert/*</code> and <code>gerdal/*4*</code>. I don’t want to <br>
see the individual counts, just the total. Of course, I could just do:</p>

<pre><code>wc all_data
</code></pre>

<p>Since this file is a concatenation of the smaller files. Yes, this <br>
works, but I had to create the <code>all_data</code> file to do this. Thus, I <br>
have wasted a precious 10445 bytes of hard disk space. We can do this <br>
<em>without</em> creating a temporary file, but first I have to show you two <br>
more commands: <code>head</code> and <code>tail</code>. These commands print the first few, <br>
or last few, lines of a file, respectively. Try them out on <br>
<code>all_data</code>:</p>

<pre><code>head all_data
tail all_data
</code></pre>

<p>The <code>-n</code> option to either of these commands can be used to print the <br>
first or last <code>n</code> lines of a file. To print the first/last line of the <br>
file use:</p>

<pre><code>head -n 1 all_data
tail -n 1 all_data
</code></pre>

<p>Let’s turn back to the problem of printing only the total number of <br>
lines in a set of files without creating any temporary files. To do <br>
this, we want to tell the shell to take the output of the <code>wc Bert/* <br>
gerdal/*4*</code> and send it into the <code>tail -n 1</code> command. The <code>|</code> <br>
character (called pipe) is used for this purpose. Enter the following <br>
command:</p>

<pre><code>wc Bert/* gerdal/*4* | tail -n 1
</code></pre>

<p>This will print only the total number of lines, characters, and words <br>
across all of these files. What is happening here? Well, <code>tail</code>, like <br>
many command line programs will read from the <em>standard input</em> when it <br>
is not given any files to operate on. In this case, it will just sit <br>
there waiting for input. That input can come from the user’s keyboard <br>
<em>or from another program</em>. Try this:</p>

<pre><code>tail -n 2
</code></pre>

<p>Notice that your cursor just sits there blinking. Tail is waiting for <br>
data to come in. Now type:</p>

<pre><code>French
fries
are
good
</code></pre>

<p>then Ctrl-d. You should get the lines:</p>

<pre><code>are
good
</code></pre>

<p>printed back at you due to you asking tail to return the last two by <br>
doing -n 2. The Ctrl-d keyboard shortcut inserts an <em>end-of-file</em> <br>
character. It is sort of the standard way of telling the program “I’m <br>
done entering data”. The <code>|</code> character replaces the data from the <br>
keyboard with data from another command. You can string all sorts of <br>
commands together using the pipe.</p>

<p>The philosophy behind these command line programs is that none of them <br>
really do anything all that impressive. BUT when you start chaining <br>
them together, you can do some really powerful things really <br>
efficiently. If you want to be proficient at using the shell, you must <br>
learn to become proficient with the pipe and redirection operators: <br>
<code>|</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code> and <code>2&gt;&gt;</code>.</p>



<h2 id="a-sorting-example">A sorting example</h2>

<p>Let’s create a file with some words to sort for the next example. We <br>
want to create a file which contains the following names:</p>

<pre><code>Bob
Alice
Diane
Charles
</code></pre>

<p>Navigate to <code>/tmp</code> and open an empty file with nano or notepad:</p>

<pre><code>nano toBeSorted
</code></pre>

<p>Now enter the four names as shown above. When you are done, press <br>
Ctrl-o to write out the file. Press enter to use the file name <br>
<code>toBeSorted</code>. Then press Ctrl-x to exit <code>nano</code> (or do equivalent <br>
things in notepad).</p>

<p>When you are back to the command line, enter the command:</p>

<pre><code>sort toBeSorted
</code></pre>

<p>Notice that the names are now printed in alphabetical order.</p>

<p>Try looking at this file with <code>less</code> - note that the file itself has not changed.</p>

<hr>



<h1 id="short-exercise-6">Short Exercise</h1>

<p>Use the <code>echo</code> command and the append operator, <code>&gt;&gt;</code>, to append your <br>
name to the file, then sort it and send the output to a new file <br>
called Sorted.</p>

<p>Once you have looked at the new file, remove both toBeSorted and Sorted.</p>

<hr>

<p>Let’s navigate back to <code>~/linux_shell/shell/data</code>. Enter the <br>
following command:</p>

<pre><code>wc Bert/* | sort -k 3 -n
</code></pre>

<p>We are already familiar with what the first of these two commands <br>
does: it creates a list containing the number of characters, words, <br>
and lines in each file in the <code>Bert</code> directory. This list is then <br>
piped into the <code>sort</code> command, so that it can be sorted. Notice there <br>
are two options given to sort:</p>

<ol>
<li><code>-k 3</code>: Sort based on the third column</li>
<li><code>-n</code>: Sort in numerical order as opposed to alphabetical order</li>
</ol>

<p>Notice that the files are sorted by the number of characters.</p>

<hr>



<h1 id="short-exercise-7">Short Exercise</h1>

<p>Use the <code>man</code> command to find out how to sort the output from <code>wc</code> in <br>
reverse order.</p>

<hr>



<h1 id="short-exercise-8">Short Exercise</h1>

<p>Combine the <code>wc</code>, <code>sort</code>, <code>head</code> and <code>tail</code> commands so that only the <br>
<code>wc</code> information for the largest file is listed</p>

<p>Hint: To print the smallest file, use:</p>

<pre><code>wc Bert/* | sort -k 3 -n | head -n 1
</code></pre>

<hr>



<h1 id="putting-commands-into-a-script-and-execution-permission-super-useful">Putting commands into a script and execution permission [Super Useful]</h1>

<p>Printing the smallest file seems pretty useful. We don’t want to type <br>
out that long command often. Let’s create a simple script, a simple <br>
program, to run this command. The program will look at all of the <br>
files in the current directory and print the information about the <br>
smallest one. Let’s call the script <code>smallest</code>. We’ll use <code>nano</code> or <code>notepad</code> to <br>
create this file. Navigate to the <code>data</code> directory, then:</p>

<pre><code>nano smallest
</code></pre>

<p>Then enter the following text:</p>

<pre><code>#!/bin/bash
wc * | sort -k 3 -n | head -n 1
</code></pre>

<p>Now, <code>cd</code> into the <code>Bert</code> directory and enter the command <br>
<code>../smallest</code>. Notice that it says permission denied. This happens <br>
because we haven’t told the shell that this is an executable <br>
file. If you do <code>ls -l ../smallest</code>, it will show you the permissions on  <br>
the left of the listing.</p>

<p>Enter the following commands:</p>

<pre><code>chmod a+x ../smallest
../smallest
</code></pre>

<p>The <code>chmod</code> command is used to modify the permissions of a file. This <br>
particular command modifies the file <code>../smallest</code> by giving all users <br>
(notice the <code>a</code>) permission to execute (notice the <code>x</code>) the file. If <br>
you enter:</p>

<pre><code>ls -l ../smallest
</code></pre>

<p>You will see that the file permissions have changed.  <br>
Congratulations, you just created your first shell script!</p>



<h1 id="searching-files">Searching files</h1>

<p>You can search the contents of a file using the command <code>grep</code>. The <br>
<code>grep</code> program is very powerful and useful especially when combined <br>
with other commands by using the pipe. Navigate to the <code>Bert</code> <br>
directory. Every data file in this directory has a line which says <br>
“Range”. The range represents the smallest frequency range that can be <br>
discriminated. Lets list all of the ranges from the tests that Bert <br>
conducted:</p>

<pre><code>grep Range *
</code></pre>

<p>Now add the –color switch:</p>

<pre><code>grep --color Range *
</code></pre>

<hr>



<h1 id="short-exercise-9">Short Exercise</h1>

<p>Create an executable script called <code>smallestrange</code> in the <code>data</code> <br>
directory, that is similar to the <code>smallest</code> script, but prints the <br>
file containing the file with the smallest Range. Use the commands <br>
<code>grep</code>, <code>sort</code>, and <code>tail</code> to do this.</p>

<hr>



<h1 id="finding-files">Finding files</h1>

<p>The <code>find</code> program can be used to find files based on arbitrary <br>
criteria. Navigate to the <code>data</code> directory and enter the following <br>
command:</p>

<pre><code>find . -print
</code></pre>

<p>This prints the name of every file or directory, recursively, starting <br>
from the current directory. Let’s exclude all of the directories:</p>

<pre><code>find . -type f -print
</code></pre>

<p>This tells <code>find</code> to locate only files. Now try this command:</p>

<pre><code>find . -type f -name "*1*"
</code></pre>

<p>The <code>find</code> command can acquire a list of files and perform some <br>
operation on each file. Try this command out:</p>

<pre><code>find . -type f -exec grep Volume {} \;
</code></pre>

<p>This command finds every file starting from <code>.</code>. Then it searches each <br>
file for a line which contains the word “Volume”. The <code>{}</code> refers to <br>
the name of each file. The trailing <code>\;</code> is used to terminate the <br>
command.</p>

<p>Using find like this can be slow, because it is calling a new instance <br>
of <code>grep</code> for each item the <code>find</code> returns. It’s possible to use find <br>
with xargs to overcome this problem if necessary:</p>

<pre><code>find . -type f -print | xargs grep Volume
</code></pre>

<p><code>find</code> generates a list of all the files we are interested in,  <br>
then we pipe them to <code>xargs</code>.  <code>xargs</code> takes the items given to it  <br>
and passes them as arguments to <code>grep</code>.  <code>xargs</code> generally only creates <br>
a single instance of <code>grep</code> (or whatever program it is running).</p>

<hr>



<h1 id="short-exercise-10">Short Exercise</h1>

<p>Navigate to the <code>data</code> directory. Use one <code>find</code> command to perform each <br>
of the operations listed below (except number 2, which does not <br>
require a <code>find</code> command):</p>

<ol>
<li><p>Find any file whose name is “NOTES” within <code>data</code> and delete it </p></li>
<li><p>Create a new directory called <code>cleaneddata</code> (note: this should in the same  directory as <code>data</code>)</p></li>
<li><p>Move all of the files within <code>data</code> to the <code>cleaneddata</code> directory</p></li>
<li><p>Rename all of the files to ensure that they end in <code>.txt</code> (note: <br>
it is ok for the file name to end in <code>.txt.txt</code></p></li>
</ol>

<p>Hint: If you make a mistake and need to start over just do the <br>
following:</p>

<ol>
<li><p>Navigate to the <code>shell</code> directory</p></li>
<li><p>Delete the <code>data</code> directory with <code>rm -r data</code></p></li>
<li><p>Enter the command: <code>git checkout -- data</code> You should see that the <br>
data directory has reappeared in its original state</p></li>
</ol>



<h2 id="bonus-fun">BONUS FUN</h2>

<p>Redo exercise 4, except rename only the files which do not already end <br>
in <code>.txt</code>. You will have to use the <code>man</code> command to figure out how to <br>
search for files which do not match a certain name.</p>

<hr>



<h1 id="what-did-we-miss-out-super-useful">What did we miss out? [Super Useful]</h1>

<p>There’s more we could have fitted in to this session if it were <br>
longer. Sometimes it’s just useful to know that something exists so <br>
that you can research its use later. Here’s a list of programs we find <br>
super useful on the command line:</p>



<h2 id="awk">awk</h2>

<p>The Microsoft Excel of the command line. Can print elements from a row <br>
of text. Often used with grep and sed.</p>



<h2 id="locate">locate</h2>

<p>A program which finds files in your filesystem by consulting a database.</p>



<h2 id="sed">sed</h2>

<p>The stream editor - edit files on the fly in your scripts. Often used <br>
with awk and grep.</p>



<h2 id="tail-f">tail -f</h2>

<p>The -f argument to tail “follows” a file. You can use this to watch a <br>
file grow. Often used to watch system log files.</p>



<h2 id="sudo">sudo</h2>

<p>“Super User DO”. Run a command as if you were the <em>root user</em> of the <br>
system. For admin tasks.</p>



<h2 id="ssh-scp-and-sftp">ssh, scp and sftp</h2>

<p>Network transparency. Jump from machine to machine with ssh and use it <br>
to execute commands on remote machines. Use scp and sftp to transfer files.</p>



<h2 id="regular-expressions">Regular expressions</h2>

<p>Many programs use regular expressions, which are a more advanced <br>
version of the wild cards used by the shell. Annoyingly, there are <br>
many slightly different flavours of regular expressions, but <br>
eventually, you have to get your teeth into them (especially useful <br>
with sed and grep).</p>



<h2 id="bashrc-and-bashprofile">.bashrc and .bash_profile</h2>

<p>This files are executed when the shell starts. You can put any command <br>
in there. Often used to set an alias for a long command and to set <br>
environment variables like PATH so they are correct each time you open <br>
a shell.</p>



<h2 id="characters">` characters</h2>

<p>` characters have a special action. E.g.:</p>

<pre><code>ls -l `which ls`
</code></pre>



<h2 id="clear-and-reset">clear and reset</h2>

<p>To clear your terminal, type <code>clear</code>. If your terminal goes all wierd, <br>
try <code>reset</code>.</p>



<h2 id="rename">rename</h2>

<p>If you have lots of files to rename and you need to do it according to <br>
some pattern, then <code>rename</code> is your tool.</p>



<h2 id="script">script</h2>

<p>Allows you to log a session.</p>



<h2 id="screen">screen</h2>

<p>Run several shells in a single terminal window in such a way that the <br>
session is <em>immune to the network connection being lost</em>.</p>

<hr>

<p>Please take a look at the [Shell Cheat Sheet] <br>
(<a href="http://rcg.group.shef.ac.uk/courses/linux/shell-cheatsheet.html">http://rcg.group.shef.ac.uk/courses/linux/shell-cheatsheet.html</a>) <br>
to refresh what you have learned and to get a quick overview of some <br>
other topics.</p>

<p>If you have reached this part of the document and you have time left <br>
or you would like some further practice after the workshop then please <br>
attempt the <a href="http://rcg.group.shef.ac.uk/courses/linux/exercises/shell-exercises.html">1000 Genome Shell <br>
exercises</a></p>


</body>
</html>
