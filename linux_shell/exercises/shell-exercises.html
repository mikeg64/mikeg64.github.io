<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="web documentation for IntroductiontoLinux ">

    <link rel="stylesheet" type="text/css" media="screen" href="../stylesheets/general.css">

    <title>Shell exercises</title>
  </head>

   <body>
  
  <!-- global navigation -->
<div id="globalNavigation"> 
  <!-- global navigation links -->
        <a href="#content"><img src="../images/spacer.gif" alt="skip to content" width="1" height="1" /></a> <img src="../images/spacer.gif" alt=" " width="1" height="1" />
		<span><a href="http://shef.ac.uk//www.sheffield.ac.uk/" accesskey="1">Home</a> |</span>
		<span><a href="http://shef.ac.uk//www.sheffield.ac.uk/contact/" accesskey="c">Contact</a> |</span> 
		<span><a href="https://www.sheffield.ac.uk/muse/login" accesskey="m">Log in to MUSE</a></span>
  <!-- // global navigation links -->
   <!-- search engine -->	
  <form name="gs" method="get" action="http://google.shef.ac.uk/search" id="searchBox">
     <p> 
     <label for="searchterms">Search for</label>
      <input type="text" name="q" size="20" maxlength="100" value=" your search" id="searchterms" onfocus="value=''" />
      <!-- <input name="Go" type="submit" value="Go" /> -->
      <input type="submit" name="btnG" value="Search" class="submit" />
    </p>
            <input type="hidden" name="sort" value="date:D:L:d1" />
            <input type="hidden" name="output" value="xml_no_dtd" />
            <input type="hidden" name="ie" value="UTF-8" />
            <input type="hidden" name="oe" value="UTF-8" />
            <input type="hidden" name="client" value="default_frontend" />
            <input type="hidden" name="proxystylesheet" value="default_frontend" />
            <input type="hidden" name="site" value="default_collection" />
  </form>
  <!-- // search engine -->
</div>
<!-- // global navigation -->





    <!-- HEADER -->
<div id="header">

  <table summary="Header Table"><tr>
	 <td id="headerLeft">
		  <div id="headerCrest">
			<a href="http://www.shef.ac.uk/"><img src="../images/crest-l.gif" alt="The University of Sheffield" /></a> 
		  </div>
    </td>
	<td id="headerRight">
	        <!-- page heading  -->
		  <div id="headerTitle"> 
		<h1 id="pageTitle">Shell exercises</h1>
		  </div>
		  <!-- // page heading -->
    </td>
  </tr>
 </table>
</div>    
  



<h1 id="1000-genome-shell-excercises">1000 Genome Shell excercises</h1>

<p>Let’s try out your new/existing shell skills on some real data.</p>

<p>The file <code>1000gp.vcf</code> is a small sample (1%) of a very large text file <br>
containing human genetics data. Specifically, it describes genetic variation in <br>
three African individuals sequenced as part of the <a href="http://www.1000genomes.org">1000 Genomes <br>
Project</a>. </p>



<h2 id="exercise-part-1-setup">Exercise Part 1 (setup)</h2>

<ul>
<li><p>If you had forgotten where you downloaded the file, how would you locate the <br>
path of all files with that name on the computer (using the shell)?  </p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p><code>$ man find</code></p>
</blockquote>

<p><strong>Answer:</strong></p>

<blockquote>
  <p><code>$ find / -name "1000gp.vcf"</code></p>
</blockquote></li>
<li><p>It’s usually a good idea to use an empty directory as a workspace so that <br>
other files don’t get in the way (or accidentally get overwritten or deleted). <br>
Create a new subdirectory directory named “sandbox”, move our data file there, <br>
and make the directory your current working directory (sandbox should be the <br>
last part of the path given when you type <code>pwd</code>. </p>

<p><strong>Answer:</strong></p>

<blockquote>
  <pre class="prettyprint"><code class="language-bash hljs ">$ mkdir sandbox
$ mv /home/orion/Downloads/<span class="hljs-number">1000</span>gp.vcf sandbox
$ <span class="hljs-built_in">cd</span> sandbox</code></pre>
</blockquote></li>
</ul>



<h2 id="exercise-part-2-analysis">Exercise Part 2 (analysis)</h2>

<ul>
<li><p>The data file you downloaded is a line-based text file. The “vcf” extension <br>
lets us know that it’s in a specific text format, namely “Variant Call <br>
Format”. The file starts with a bunch of comment lines (they start with “#” or <br>
“##”), and then a large number of data lines. The human genome can be thought <br>
of as an encyclopedia, where each chromosome is a volume. Each volume is just <br>
a long string of characters, but rather than the english alphabet, the genome <br>
uses just the characters “A”, “C”, “G”, and “T”. This VCF file lists the <br>
differences between the three African individuals and a standard “individual” <br>
called the reference (actually based upon a few different people). Each line <br>
in the file corresponds to a difference. The line tells us the position of the <br>
difference (chromosome and position), the genetic sequence in the reference, <br>
and the corresponding sequence in each of the three Africans. Research is <br>
ongoing to understand the full effects of these genetic differences; some <br>
cause diseases such as Tay-Sachs and Hemophilia, while others determine your <br>
blood type and eye color.</p>

<p>Before we start processing the file, let’s get a high-level view of the file <br>
that we’re about to work with.</p>

<p>What’s the file size (in kilo-bytes), and how many lines are in the file?</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>There’s an option to <code>ls</code> that will print the file sizes in a more <br>
  human-friendly format.</p>
</blockquote>

<p><strong>A hint about the number of lines:</strong></p>

<blockquote>
  <p><code>$ man wc</code></p>
</blockquote>

<p><strong>Answer:</strong></p>

<blockquote>
  <p>We should get a file size around 3.6 MB with: <br>
  <code>$ ls -lh 1000gp.vcf</code> <br>
  Alternatively, the command <code>du</code> can be used to achieve a similar result: <br>
  <code>$ du -h 1000gp.vcf</code></p>
  
  <p>We find there are 45034 lines with: <br>
  <code>$ wc -l 1000gp.vcf</code></p>
</blockquote></li>
<li><p>Because this file is so large, you’re going to almost always want to pipe <br>
(“|”) the result of any command to <code>less</code> (a simple text viewer, type ‘q’ to <br>
exit) or <code>head</code> (to print the first 10 lines) so that you don’t accidentally <br>
print 45,000 lines to the screen.</p>

<p>Let’s start by printing the first 5 lines to see what it looks like.  </p>

<p><strong>Answer:</strong></p>

<blockquote>
  <p><code>$ head -5 1000gp.vcf</code></p>
</blockquote></li>
<li><p>That isn’t very interesting; it’s just a bunch of the comments at the <br>
beginning of the file (they all start with “#”)! Print the first 20 lines to see <br>
more of the file.</p>

<p><strong>Answer:</strong></p>

<blockquote>
  <p><code>$ head -20 1000gp.vcf</code></p>
</blockquote></li>
<li><p>Okay, so now we can see the basic structure of the file. A few comment lines <br>
that start with “#” or “##” and then a bunch of lines of data that contain all <br>
the data and are pretty hard to understand. Each line of data contains the <br>
same number of fields, and all fields are separated with TABs. These fields <br>
are:</p>

<ol><li>the chromosome (which volume the difference is in)</li>
<li>the position (which character in the volume the difference starts at)</li>
<li>the ID of the difference</li>
<li>the sequence in the reference human(s)</li></ol>

<p>The rest of the columns tell us, in a rather complex way, a bunch of <br>
additional information about that position, including: the predicted sequence <br>
for each of the three Africans and how confident the scientists are that these <br>
sequences are correct.</p>

<p>To start analyzing the actual data, we have to remove the header. How can we <br>
print the first 10 non-header lines (those that <em>don’t</em> start with a “#”)?</p>

<p><strong>Hint:</strong> <br>
$ man grep</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>You can use a pipe (“|”) to connect the output of <code>grep</code> to the input of <br>
  <code>head</code>.</p>
</blockquote>

<p><strong>Hint:</strong> <br>
In <code>grep</code> regular expressions, the carat ‘^’ character matches the start of a <br>
line and the dollar sign ‘$’ matches the end of a line. Thus, the following <br>
will print all non-blank lines from <code>file</code>: <br>
<script type="math/tex" id="MathJax-Element-1"> grep -v "^</script>” file</p>

<p><strong>Our answer:</strong></p>

<blockquote>
<pre><code>$ grep -v "^#" 1000gp.vcf | head
</code></pre>
  
  <p>Why are neither of these correct? <br>
      <script type="math/tex" id="MathJax-Element-2"> grep -v “#” 1000gp.vcf | head  
      </script> grep -v “^##” 1000gp.vcf | head</p>
</blockquote></li>
<li><p>How many lines of data are in the file (rather than counting the number of <br>
header lines and subtracting, try just counting the number of data lines)?</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>Instead of piping to <code>head</code>, try piping to <code>wc</code>.</p>
</blockquote>

<p><strong>Our Answer:</strong></p>

<blockquote>
<pre><code>$ grep -v "^#" 1000gp.vcf | wc -l
</code></pre>
  
  <p>should print <code>45024</code></p>
</blockquote></li>
<li><p>Where these differences are located can be important. If all the differences <br>
between two encyclopedias were in just the first volume, that would be <br>
interesting. The first field of each data line is the name of the chromosome <br>
that the difference occurs on (which volume we’re on). Print the first 10 <br>
chromosomes, one per line.</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>You can extract a column from a tab-delimited text file using the <code>cut</code> <br>
  command.</p>
</blockquote>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>Use <code>grep</code> to print only non-comment lines, and <code>cut</code> to extract the <br>
  chromosome column.</p>
</blockquote>

<p><strong>Our Answer:</strong></p>

<blockquote>
<pre><code>$ grep -v "^#" 1000gp.vcf | cut -f 1 | head
</code></pre>
</blockquote></li>
<li><p>As you should have observed, the first 10 lines are on numbered chromosomes. <br>
Every normal cell in your body has 23 pairs of chromosomes, 22 pairs of <br>
“autosomal” chromosomes (these are numbered 1-22) and a pair of sex <br>
chromosomes (two Xs if you’re female, an X and a Y if you’re male). If you’ve <br>
heard of the genetics company <a href="https://www.23andme.com">23andMe</a>, the 23 <br>
refers to these 23 pairs of chromosomes. </p>

<p>Let’s look at which chromosomes these variations are on. Print a list of the <br>
chromosomes that are in the file (each chromosome name should only be printed <br>
once, so you should only print 23 lines).</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>You need to remove all the duplicate lines from your previous answer.</p>
</blockquote>

<p><strong>Hint:</strong></p>

<blockquote>
  <p><code>sort</code> has an option that should make this easier.</p>
</blockquote>

<p><strong>Our Answer:</strong></p>

<blockquote>
<pre><code>$ grep -v "^#" 1000gp.vcf | cut -f 1 | sort -u
</code></pre>
</blockquote></li>
<li><p>Rather than using <code>sort</code> to print unique results, a common pipeline is to <br>
first sort and then pipe to another UNIX command, <code>uniq</code>. The <code>uniq</code> command <br>
takes <em>sorted</em> input and prints only unique lines, but it provides more <br>
flexibility than just using <code>sort</code> by itself. Keep in mind, if the input isn’t <br>
sorted, <code>uniq</code> won’t work properly.</p>

<p>Using <code>sort</code> and <code>uniq</code>, print the number of times each chromosome occurs in <br>
the file.</p>

<p><strong>Hint:</strong></p>

<blockquote>
<pre><code>$ man uniq
</code></pre>
</blockquote>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>Instead of using <code>sort</code> to remove duplicates, just use it to sort and pipe <br>
  the result to <code>uniq</code>.</p>
</blockquote>

<p><strong>Our Answer:</strong></p>

<blockquote>
<pre><code>$ grep -v "^#" 1000gp.vcf | cut -f 1 | sort | uniq -c
</code></pre>
</blockquote></li>
<li><p>Add to your previous solution to list the chromosomes from most frequently <br>
observed to least frequently observed.</p>

<p><strong>Hint:</strong></p>

<blockquote>
<pre><code>$ man sort
</code></pre>
</blockquote>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>Make sure you’re sorting in descending order. By default, <code>sort</code> sorts in <br>
  ascending order.</p>
</blockquote>

<p><strong>Our Answer:</strong></p>

<blockquote>
<pre><code>$ grep -v "^#" 1000gp.vcf | cut -f 1 | sort | uniq -c | sort -n -r
</code></pre>
  
  <p>should output the following:</p>

<pre><code>3721 2
3387 1
3224 4
3219 3
2894 5
2860 6
2527 8
2525 7
2203 10
2166 11
2032 12
1865 9
1656 13
1409 14
1362 16
1304 X
1275 18
1265 15
1097 17
 993 20
 814 19
 661 21
 565 22
</code></pre>
</blockquote></li>
<li><p>The autosomal chromosomes (1-22) are named according to their size. The <br>
largest of them is chromosome 1, while the smallest is chromosome 22. Does it <br>
look like differences occur relatively randomly across the genome, or are some <br>
chromosomes more different than you’d expect at random (very roughly taking <br>
their sizes into account)?</p>

<p>It’s worth noting that the chromosomes were numbered by the sizes of the <br>
actual molecules, not how much of them had been sequenced.</p>

<p>Wikipedia has a nice table of chromosome sizes and how much of each has been <br>
sequenced (and you can sort it): <br>
<a href="http://en.wikipedia.org/wiki/Human_chromosome#Human_chromosomes">http://en.wikipedia.org/wiki/Human_chromosome#Human_chromosomes</a></p>

<p>Notice anything?</p>

<p><strong>Our Hypothesis:</strong></p>

<blockquote>
  <p>Since variation can only be found in the known sequence, the order you <br>
  printed corresponds closely to ordering by the number of bases sequenced <br>
  (rather than the total number of bases). </p>
  
  <p>Given this, it seems like differences occur relatively randomly across the <br>
  genome. We see more differences on longer chromosomes, fewer on shorter, <br>
  without any striking outliers.</p>
</blockquote></li>
<li><p>This is great, but biologists might also like to see the chromosomes ordered <br>
by their number (not dictionary order), since different chromosomes have <br>
different attributes and this ordering allows them to find a specific <br>
chromosome more easily.</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>A lot of the power of <code>sort</code> comes from the fact that you can specify which <br>
  fields to sort on, and the order in which to sort them. In this case you <br>
  only need to sort on one field.</p>
</blockquote>

<p><strong>Answer:</strong></p>

<blockquote>
<pre><code>$ grep -v "^#" 1000gp.vcf | cut -f 1 | sort | uniq -c | sort -k 2n
</code></pre>
</blockquote></li>
</ul>



<h2 id="exercise-part-3-scripts-and-svn">Exercise Part 3 (scripts and svn)</h2>

<ul>
<li><p>Wonderful! Now we have a (long) command for printing chromosome statistics <br>
from our <code>1000gp.vcf</code> file. Using <code>nano</code>, create a new file, “chrom_stats.sh”, <br>
with just your answer to the previous question in it.</p>

<p><strong>Answer:</strong></p>

<blockquote>
  <p>Type the following to open a new file: <br>
      $ nano chrom_stats.sh <br>
   Type in the command. Type ^o to save and ^x (where ^ means the control key).</p>
</blockquote></li>
<li><p>Just to be illustrate the flexibility of the shell, try creating the same file <br>
directly from the shell (without a text editor). Once you do, you can use <br>
<code>cat</code> to make sure the contents of the file are exactly what you expect.</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>You can use <code>echo</code> to print something and <code>&gt;</code> to redirect to a file.</p>
</blockquote>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>Since our long command has double-quotes in it, you either need to use <br>
  single-quotes or escape these with back-slashes.</p>
</blockquote>

<p><strong>Answer:</strong> <br>
<script type="math/tex" id="MathJax-Element-3"> echo ‘grep -v “^#” 1000gp.vcf | cut -f 1 | sort | uniq -c | sort -k 2n’ > chrom_stats.sh  
</script> cat chrom_stats.sh</p></li>
<li><p>Now, execute your new script to print the chromosome statistics.</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>You may have to change the permissions to allow you to execute it.</p>
</blockquote>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>It’s good form to only make permissions as permissive as necessary. So, <br>
  rather than allow everyone to execute the file, it is better to just allow <br>
  you to execute it.</p>
</blockquote>

<p><strong>Answer:</strong> <br>
<script type="math/tex" id="MathJax-Element-4"> chmod u+x chrom_stats.sh  
</script> ./chrom_stats.sh</p>

<blockquote>
  <p>Note that it is <code>u+x</code> instead of just <code>+x</code> or <code>a+x</code>. This only adds the <br>
  ability for the owner to execute it, whereas the other two options would <br>
  allow anyone to execute it.</p>
</blockquote></li>
<li><p>We’d like to be able to use this script in the future with arbitrary VCF <br>
files, instead of just our <code>1000gp.vcf</code> file. Edit the script so that it takes <br>
VCF-formatted text input on stdin and prints out chromosome statistics on <br>
stdout. This is simpler than you might think.</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>If <code>grep</code> isn’t given an input file, it will read from stdin.</p>
</blockquote>

<p><strong>Answer:</strong></p>

<blockquote>
  <p>Change <br>
  <code>grep -v "^#" 1000gp.vcf | ...</code> <br>
  to <br>
  <code>grep -v "^#" | ...</code></p>
  
  <p>Since this is in a file instead of the shell prompt, we aren’t showing the <br>
  “$” at the beginning of the line.</p>
</blockquote></li>
<li><p>Now that we have a script that reads from stdin and prints to stdout, how do <br>
we run it on the <code>1000gp.vcf</code> file to get the same output as before?</p>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>The <code>cat</code> command is used to print files to stdout.</p>
</blockquote>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>You can pipe the output of <code>cat</code> directly into our script.</p>
</blockquote>

<p><strong>Hint:</strong></p>

<blockquote>
  <p>Just like before, in order to tell the shell that the <code>chrom_stats.sh</code> file <br>
  we want to execute is the one in our current directory, we need to use <br>
  <code>./chrom_stats.sh</code>.</p>
</blockquote>

<p><strong>Answer:</strong> <br>
<code>$ cat 1000gp.vcf | ./chrom_stats.sh</code></p></li>
</ul>

<p><strong>Fin.</strong>  <br>
Comments, questions, and suggestions are encouraged and appreciated. <br>
Thanks to Tommy Guy, Jon Pipitone, Greg Wilson, and Elango Cheran for their help <br>
with these exercises.</p>

</body>
</html>
